---
title: "Predict racetime Olympic Marathon"
author: "Brecht Dewilde"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
```

## Introduction 
The basis dataset is the historical dataset obtained from Kaggle: [dataset ](ttps://www.kaggle.com/heesoo37/120-years-of-olympic-history-athletes-and-results). This is a historical dataset containing the outcomes of all the games from Athens 1896 to Rio 2016. The full dataset contains 271 116 rows and 15 columns. Each row corresponds to an individual athlete competing in an individual Olympic event. The columns are:

1. ID - Unique number for each athlete
2. Name - Athlete's name
3. Sex - M or F
4. Age - Integer
5. Height - In centimeters
6. Weight - In kilograms
7. Team - Team name
8. NOC - National Olympic Committee 3-letter code
9. Games - Year and season
10. Year - Integer
11. Season - Summer or Winter
12. City - Host city
13. Sport - Sport
14. Event - Event
15. Medal - Gold, Silver, Bronze, or NA


Preview of the dataset: 
```{r data preview, echo=FALSE}
setwd("~/Github/Predicting-the-olympic-games/IDA code/Marathon")
fData <- read.csv(file.path("Data\\kaggle", "athlete_events.csv"))
head(fData)
```

### Selecting marathon events
At this point the focus is to predict the racetime of a racer competing in an Olympic marathon. Therefore, the following analysis will be performed on data that only contains instances of marathon runners. During the complete analysis, a distinction will be made between men and women, therefore two different datasets are created. The dimensions of these datasets are:

```{r selecting only rows concerning marathon, echo=FALSE, eval=FALSE}
# Data selection
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")

# Dimension printing
paste("The runners dataset contains:", dim(marathon)[1], "runners.")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
```


### Creating a basis dataset
The targetvalue is the race time of the athletes. However, the basis dataset does not contain the actual racetimes, therefore these have to be scraped from another source. The [site](http://www.olympicgamesmarathon.com/results.php) contains the results from all the olympic marathons, a python script is written to scrape these racetimes. Consequently, a dataframe for each year is created and added to the directory: "scraped\race_times". First these dataframes are combined into one. Secondly, the basis dataframe is merged to it. 

However, these are only male runners. In addition, there are multiple athletes whereof the race time is unknown. Specifically, for the olympics in the past. Athletes whereof the target value is unknown are not valuable for our analysis and will therefore be deleted. The merge condition is as follows:"if there are at least two words in the name vector that match then the rows will be merged together". We obtain a dataset containing  1032 athletes. This will be used as start point for our analysis.


```{r reading the scraped data, echo=FALSE, eval=FALSE}
dir =  "Data\\scraped\\race times"
files = list.files(path = "Data\\scraped\\race times")
data_frames <- vector(mode = "list", length = length(files))

index <-1 
for(file in files){
  data_frames[[index]] <- read.csv(file.path(dir, file))
  year <- gsub("[^0-9]", replacement = "", file)
  data_frames[[index]]$Year <- year
  index <- index +  1
}
race_times <- do.call("rbind", data_frames)
rm("index", "dir", "file", "files", "data_frames", "year")
```


```{r combining the two datasets, echo=FALSE, eval=FALSE, warning=FALSE}
# exclude racers without the racetimes
race_times <- filter(race_times, Time != "")

# The name column in the basis dataset contains first and last name as one, thus i have to paste 
race_times$full_name <- paste(race_times$FirstName, race_times$LastName)

# Reformat Name column to string such that we can merge
marathonM$Name <- as.character(marathonM$Name)

# Function to check whether there are two matches of words between names
match_names <- function(name1, year1 = 0, name2, year2){
    vec_name1 <- unlist(strsplit(name1, split = " "))
    vec_name2 <- unlist(strsplit(name2, split = " "))
    return(length(intersect(vec_name1, vec_name2)) >= 2 && year1 == year2)
}

# cartesian product of all combinations
combinations <- mmpf::cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))

# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
  indicator[i] <- match_names(combinations$Name[i], combinations$Year.x[i], combinations$full_name[i], combinations$Year.y[i])
}

# Filter on the indicator vector
marathonM_times <- combinations[indicator,]

rm("combinations", "marathon", "race_times", "i", "fData", "marathonM")
```

```{r reordering the columns and cleaning the data, echo=FALSE, eval=FALSE, warning=FALSE}
# reordering the columns
marathonM_times$Time <- as.POSIXct(marathonM_times$Time, format="%H:%M:%S")
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")

# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)

# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
  return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}

convert_to_secs <- function(time){
    return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}

# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
marathonM_times$Time_secs <- convert_to_secs(marathonM_times$Time)
marathonM_times$Time <- format(marathonM_times$Time, "%H:%M:%S")

# all rows that contain na values will be removed
marathonM_times <- na.omit(marathonM_times)
save(marathonM_times, file = "Data\\Rda\\marathonM_times.RData")
rm("convert_to_mins", "convert_to_secs")
```

```{r preview of the basis dataset, echo=FALSE, warning=FALSE}
marathonM_times <- load("~/Github/Predicting-the-olympic-games/IDA code/Marathon/Data/Rda/marathonM_times.RData")
rm("backup", "marathonF", "indicator")
head(marathonM_times)
```

### Adding additional variables based on the available onces
Prevention of data leakage. At this point I have to select a time window in which the features will be calculated.

The variables that will be added are:
** BMI **
** gdp ** 
** population **

The kaggle page: "https://www.kaggle.com/chadalee/olympics-data-cleaning-exploration-prediction/data" explains why it can be helpfull to add each of these variables to the dataset. 

```{r adding extra variables, echo=FALSE, warning=FALSE, eval = FALSE, warning=FALSE}
marathonM_times$BMI <- marathonM_times$Weight / (marathonM_times$Height/100)^2

# add gdp to the dataset and take into account the data leakage
gdp <- read.csv(file = file.path("Data", "world_gdp.csv"))

# gdp is in weird format, change format of the gdp database
# remove the unnecessary columns
gdp$World.Development.Indicators <- NULL
gdp$X <- NULL
gdp$X.1 <- NULL

# the first row of the dataset equals the year, make this the colNames
colNamesVec <- gdp[3,]
colnames(gdp) <- colNamesVec
colnames(gdp)[1] <- "country Name"
gdp <- gdp[-c(1,2,3), ] 

# update the basisDataFrame
marathonM_times$Gdp <- vector(length = nrow(marathonM_times))
for(i in 1:nrow(marathonM_times)){
  nationality <- as.character(marathonM_times[i,]$Nationality)
  year <- marathonM_times[i,]$Year
  if(year < as.numeric(colnames(gdp)[2])){
     marathonM_times$Gdp[i] <- NA
  }else{
     marathonM_times$Gdp[i] <- gdp %>% filter(`country Name` == nationality) %>% select(as.character(year))
  }
}

# change numeric(0) to na
idx <- !(sapply(marathonM_times$Gdp, length))
marathonM_times$Gdp[idx] <- NA
marathonM_times$Gdp <- unlist(marathonM_times$Gdp)

# add population to the dataset and take into account the data leakage
pop <- read.csv(file = file.path("Data", "world_pop.csv"))

# Remove unncessary columns
pop$Country.Code <- NULL
pop$Indicator.Name <- NULL
pop$Indicator.Code <- NULL

# Rename the columns
years <- as.character(seq(1960, 2016))
colnames(pop) <- c("country Name", years)

# update the basisDataFrame
marathonM_times$Population <- vector("numeric", length = nrow(marathonM_times))
for(i in 1:nrow(marathonM_times)){
  nationality <- as.character(marathonM_times[i,]$Nationality)
  year <- marathonM_times[i,]$Year
  if(year < as.numeric(colnames(pop)[2])){
    marathonM_times$Population[i] <- NA
  }else{
    marathonM_times$Population[i] <- pop %>% filter(`country Name` == nationality) %>% select(as.character(year))
    }
}

# change numeric(0) to na
idx <- !(sapply(marathonM_times$Population, length))
marathonM_times$Population[idx] <- NA
marathonM_times$Population <- unlist(marathonM_times$Population)


# add region indicator
regions <- read.csv(file.path("Data", "countries_regions.csv"), stringsAsFactors = FALSE)[, c(1,7)]
marathonM_times$Region <- vector(mode = "character", length = nrow(marathonM_times))
for(i in 1:nrow(marathonM_times)){
  nationality <- as.character(marathonM_times$Nationality[i])
  if(nationality %in% regions$name){
    sub <- as.character(filter(regions, name == nationality) %>% select("sub.region"))
    marathonM_times$Region[i] <- sub
  } else{
    marathonM_times$Region[i] <- NA
  }
}

rm("i", "indicator", "nationality", "sub", "year", "backup", "colNamesVec", "gdp", "marathonF", "pop", "regions", "idx", "years")
```

```{r reshaping the dataframe, echo=FALSE, eval =FALSE}
marathonM_times <- marathonM_times[,c( "ID" ,"Year" ,"full_name", "Age" ,"Height", "Weight", "BMI",  "Nationality", "Region", "Population", "Gdp", "Position", "Time", "Time_mins", "Time_secs")]
save(marathonM_times, file = "Data\\Rda\\marathonM_times1.RData")
```


### The score variable

a = 0.0000191003	b = -15599.4039272134	c = 0.0084789663
x = the time ran
a * (x + b)^2 + c



```{r read past times data file and add scores, echo=FALSE, eval =FALSE}
# read the past times dataframe
file_path = "C:\\Users\\BrechtDewilde\\Documents\\Github\\Predicting-the-olympic-games\\IDA code\\Marathon\\Data\\scraped\\world_athletics\\world_athletics.csv"
past_times <- read.csv(file_path, stringsAsFactors = FALSE)
past_times$Performance <- as.POSIXct(past_times$Performance, format="%H:%M:%S")

# delete country from the place to match places
past_times$Place <- sub("\\(([^]]+)\\)", "", past_times$Place)
past_times$Place <- trimws(past_times$Place)

# function to determine the time score
scores <- read.csv(file.path("Data", "scorings.csv"))

convert_to_secs <- function(time){
    return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}

time_score <- function(time){
  a = 0.0000191003	
  b = -15599.4039272134	
  c = 0.0084789663
  return(floor(a* (convert_to_secs(time) + b)^2 + c))
}

# time score
past_times$time_score <- time_score(past_times$Performance)
past_times$Performance <- format(past_times$Performance, "%H:%M:%S")

#  read and clean the labels database
labels <- read.csv(file.path("Data", "marathon labels.csv"), stringsAsFactors = FALSE)
labels$Date <- NULL
labels$Competition <- NULL
labels$Men.s.winner <- NULL
labels$Women.s.winner <- NULL
labels <- filter(labels, Distance == "Marathon")

# add the label of the marathon to each observation
past_times <- merge(past_times, labels, by.x = "Place", by.y = "Venue")
past_times$Distance <- NULL
past_times$Country <- NULL

# add position result for each marathon
past_times <- past_times %>% group_by(Place, Date) %>% arrange(desc(time_score)) %>% mutate(position = row_number(Place))

# function that determines the score of each marathon based on place


place_score <- function(position, label){
gold <- c(270, 220, 195, 175, 155, 145, 135, 125, 80, 70, 60, 50, 45, 40, 37, 34, 31, 29, 27, 25)
silver <- c(170,130,115,100,85,75,65,55,45,35,25,20)
bronze <- c(140, 105, 90, 75, 60, 50, 40, 30, 25, 22, 19, 17)
  if (label == "Gold"){
    if (position > length(gold)){
      return(0)
    }
    else{
      return(gold[position])
    }
    
  }else if (label == "Silver"){
     if (position > length(silver)){
      return(0)
    }
    else{
      return(silver[position])
    }
    
  } else if (label == "Bronze"){
     if (position > length(bronze)){
      return(0)
    }
    else{
      return(bronze[position])
    }
  }
}

# create column with place score
output <-  place_score(past_times$position, past_times$Label)
past_times$position_score <- output

# create column with final score
past_times$total_score <- past_times$time_score + past_times$position_score
rm("labels", "scores", "a", "b", "bronze", "c", "end", "start", "output", "file_path", "convert_to_secs", "place_score", "placing_score", "time_score")
```

```{r feature creation from past_times, echo=FALSE, eval =FALSE}
# only select observations happend before augustus 2016
Sys.setlocale("LC_TIME", "en_US.UTF-8")
past_times$Date <- as.Date(past_times$Date, format="%d %b %Y")
past_times2016 <- filter(past_times, Date < "2016-08-01")
past_times2016 <- past_times2016[complete.cases(past_times2016), ]

# express marathon time in seconds
past_times2016$Performance<- as.POSIXct(past_times2016$Performance, format="%H:%M:%S")
convert_to_secs <- function(time){
    return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}

past_times2016$Performance <- convert_to_secs(past_times2016$Performance)

# creation of the feature table
feature_table <- data.frame(name = sort(unique(past_times2016$Name)), stringsAsFactors=FALSE)

# Create of features for each athlete

# score related features
feature_table$avg_time_score <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = mean(time_score)) %>% select(mcount))$mcount
feature_table$best_time_score <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = max(time_score)) %>% select(mcount))$mcount
feature_table$avg_position_score <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = mean(position_score)) %>% select(mcount))$mcount
feature_table$best_position_score <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = max(position_score)) %>% select(mcount))$mcount
feature_table$avg_total_score <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = mean(total_score)) %>% select(mcount))$mcount
feature_table$best_total_score <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = max(total_score)) %>% select(mcount))$mcount

# position related features
feature_table$best_position <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = min(position)) %>% select(mcount))$mcount
feature_table$avg_position <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = mean(position)) %>% select(mcount))$mcount

# time related features
feature_table$best_time <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = min(Performance)) %>% select(mcount))$mcount
feature_table$avg_time <- as.data.frame(past_times2016 %>% group_by(Name) %>% summarise(mcount = mean(Performance)) %>% select(mcount))$mcount

# marathon features
feature_table$num_marathons <- as.data.frame(past_times2016 %>% group_by(Name) %>% count("Date") %>% select(n))$n

# gold marathons
temp <- as.data.frame(past_times2016 %>% group_by(Name, Label, .drop = FALSE) %>% count("Date", .drop = FALSE) %>% filter(Label == "Gold"))[, c(1,4)]
names <- feature_table$name
gold_list <- vector(mode="integer", length=length(names))
for(i in 1:length(names)){
  if(names[i] %in% temp$Name){
    gold_list[i] <- temp$n[i]
  }
  else{
    gold_list[i] <- 0
  }
}
feature_table$num_gold_marathons <- gold_list

# silver marathons
temp <- as.data.frame(past_times2016 %>% group_by(Name, Label, .drop = FALSE) %>% count("Date", .drop = FALSE) %>% filter(Label == "Silver"))[, c(1,4)]
silver_list <- vector(mode="integer", length=length(names))
for(i in 1:length(names)){
  if(names[i] %in% temp$Name){
    silver_list[i] <- temp$n[i]
  }
  else{
    silver_list[i] <- 0
  }
}
feature_table$num_silver_marathons <- silver_list

# bronze marathons
temp <- as.data.frame(past_times2016 %>% group_by(Name, Label, .drop = FALSE) %>% count("Date", .drop = FALSE) %>% filter(Label == "Bronze"))[, c(1,4)]
bronze_list <- vector(mode="integer", length=length(names))
for(i in 1:length(names)){
  if(names[i] %in% temp$Name){
    bronze_list[i] <- temp$n[i]
  }
  else{
    bronze_list[i] <- 0
  }
}
feature_table$num_bronze_marathons <- bronze_list

# save the data
save(feature_table, file = "Data\\Rda\\feature_table.RData")
save(past_times, file = "Data\\Rda\\past_times.Rdata")
save(past_times2016, file = "Data\\Rda\\past_times2016.Rdata")

rm("bronze_list", "dates", "gold_list", "i", "lct", "names", "silver_list", "convert_to_secs", "temp")
```



