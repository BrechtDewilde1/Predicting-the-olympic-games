match_names <- function(name1, name2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) == 2)
}
output <- vector(length = 46)
for(i in 1:46){
output[i] <- match_names(subs[i,1], subs[i,2])
}
# Compute the output of the function to each row
for(i in 1:length(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$full_name[i])
}
# Filter on the indicator vector
result <- combinations[indicator,]
# Function to check whether there are two matches of words between names
match_names <- function(name1, name2){
browser()
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) == 2)
}
# cartesian product of all combinations
combinations <- cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))
indicator <- vector(length = length(combinations$nam))
# Compute the output of the function to each row
for(i in 1:length(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$full_name[i])
}
# Function to check whether there are two matches of words between names
match_names <- function(name1, name2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) == 2)
}
# Filter on the indicator vector
result <- combinations[indicator,]
# Compute the output of the function to each row
for(i in 1:length(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$full_name[i])
}
}
# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$full_name[i])
}
# Filter on the indicator vector
result <- combinations[indicator,]
View(result)
# Function to check whether there are two matches of words between names
match_names <- function(name1, name2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2)
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
setwd("~/UGENT -  statistical data analysis/STATISTICAL DATA ANALYSIS/thesis/R analysis")
fData <- read.csv(file.path("Data", "athlete_events.csv"))
head(fData)
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
dir =  "Data\\scraped\\race times"
files = list.files(path = "Data\\scraped\\race times")
data_frames <- vector(mode = "list", length = length(files))
index <-1
for(file in files){
data_frames[[index]] <- read.csv(file.path(dir, file))
year <- gsub("[^0-9]", replacement = "", file)
data_frames[[index]]$Year <- year
index <- index +  1
}
race_times <- do.call("rbind", data_frames)
rm("index", "dir", "file", "files", "data_frames", "year")
paste("The racetimes dataset contains:", dim(race_times)[1], "runners.")
# exclude racers without the racetimes
race_times <- filter(race_times, Time != "")
# The name column in the basis dataset contains first and last name as one, thus i have to paste
race_times$full_name <- paste(race_times$FirstName, race_times$LastName)
# Reformat Name column to string such that we can merge
marathonM$Name <- as.character(marathonM$Name)
# Function to check whether there are two matches of words between names
match_names <- function(name1, name2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2)
}
# cartesian product of all combinations
combinations <- cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))
# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$full_name[i])
}
# Filter on the indicator vector
marathonM_times <- combinations[indicator,]
View(marathonM_times)
# Function to check whether there are two matches of words between names
match_names <- function(name1, year1, name2, year2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2 && year1 == year2)
}
View(marathonM)
rm("combinations", "marathon", "race_times", "indicator", "match_names", "i", "match_names", "fData", "marathonM")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
setwd("~/UGENT -  statistical data analysis/STATISTICAL DATA ANALYSIS/thesis/R analysis")
fData <- read.csv(file.path("Data", "athlete_events.csv"))
head(fData)
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
dir =  "Data\\scraped\\race times"
files = list.files(path = "Data\\scraped\\race times")
data_frames <- vector(mode = "list", length = length(files))
index <-1
for(file in files){
data_frames[[index]] <- read.csv(file.path(dir, file))
year <- gsub("[^0-9]", replacement = "", file)
data_frames[[index]]$Year <- year
index <- index +  1
}
race_times <- do.call("rbind", data_frames)
rm("index", "dir", "file", "files", "data_frames", "year")
paste("The racetimes dataset contains:", dim(race_times)[1], "runners.")
# exclude racers without the racetimes
race_times <- filter(race_times, Time != "")
# The name column in the basis dataset contains first and last name as one, thus i have to paste
race_times$full_name <- paste(race_times$FirstName, race_times$LastName)
# Reformat Name column to string such that we can merge
marathonM$Name <- as.character(marathonM$Name)
# Function to check whether there are two matches of words between names
match_names <- function(name1, year1, name2, year2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2 && year1 == year2)
}
# cartesian product of all combinations
combinations <- cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))
# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$Year.x[i], combinations$full_name[i], combinations$Year.y[i])
}
# Filter on the indicator vector
marathonM_times <- combinations[indicator,]
rm("combinations", "marathon", "race_times", "indicator", "match_names", "i", "match_names", "fData", "marathonM")
View(marathonM_times)
colnames(marathonM_times)
marathonM_times <- marathonM_times[, c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position", )]
marathonM_times <- marathonM_times[, c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")]
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")]
colnames(marathonM_times[2]) <- "Year"
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
View(marathonM_times)
str(marathonM_times)
as.POSIXct(marathonM_times$Year, fomrat="%Y")
marathonM_times$Year <- as.numeric(marathonM_times$Year)
str(marathonM_times)
secss <- as.numeric(marathonM_times$Time, units = "secs")
as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
strftime(as.POSIXct(marathonM_times$Time,format="%H:%M:%S"), format="%H:%M:%S")
marathonM_times$Time <- strftime(as.POSIXct(marathonM_times$Time,format="%H:%M:%S"), format="%H:%M:%S")
str(marathonM_times)
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
str(marathonM_times)
marathonM_times$Time[1]
marathonM_times$Time[1]$hours
marathonM_times$Time[1]$hour
?POSIXct
as.numeric(format(marathonM_times$Time[1], "%H"))
60*60
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
convert_to_secs <- function(){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
View(marathonM_times)
marathonM_times$Time_secs <- convert_to_secs(marathonM_times$Time)
convert_to_secs <- function(time){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
marathonM_times$Time_secs <- convert_to_secs(marathonM_times$Time)
str(marathonM_times)
View(marathonM_times)
rm("secss")
rm("convert_to_mins", "convert_to_secs")
View(marathonM_times)
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time", )]
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
marathonM_times$Time <- format(marathonM_times$Time, "%H:%M:%S")
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
convert_to_secs <- function(time){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
convert_to_secs <- function(time){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
marathonM_times$Time_secs <- convert_to_secs(marathonM_times$Time)
marathonM_times$Time <- format(marathonM_times$Time, "%H:%M:%S")
rm("convert_to_mins", "convert_to_secs")
View(marathonM_times)
# all rows that contain na values will be removed
na.omit(marathonM_times)
# all rows that contain na values will be removed
marathonM_times <- na.omit(marathonM_times)
library(tidyverse, mmpf)
# cartesian product of all combinations
combinations <- cartesianExpand(marathonM, race_times)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
setwd("~/UGENT -  statistical data analysis/STATISTICAL DATA ANALYSIS/thesis/R analysis")
fData <- read.csv(file.path("Data", "athlete_events.csv"))
head(fData)
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
head(marathonM_times)
View(marathonM_times)
head(marathonM_times)
head(marathonM_times)
# cartesian product of all combinations
combinations <- cartesianExpand(marathonM, race_times)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
setwd("~/UGENT -  statistical data analysis/STATISTICAL DATA ANALYSIS/thesis/R analysis")
fData <- read.csv(file.path("Data", "athlete_events.csv"))
head(fData)
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
dir =  "Data\\scraped\\race times"
files = list.files(path = "Data\\scraped\\race times")
data_frames <- vector(mode = "list", length = length(files))
index <-1
for(file in files){
data_frames[[index]] <- read.csv(file.path(dir, file))
year <- gsub("[^0-9]", replacement = "", file)
data_frames[[index]]$Year <- year
index <- index +  1
}
race_times <- do.call("rbind", data_frames)
rm("index", "dir", "file", "files", "data_frames", "year")
# exclude racers without the racetimes
race_times <- filter(race_times, Time != "")
# The name column in the basis dataset contains first and last name as one, thus i have to paste
race_times$full_name <- paste(race_times$FirstName, race_times$LastName)
# Reformat Name column to string such that we can merge
marathonM$Name <- as.character(marathonM$Name)
# Function to check whether there are two matches of words between names
match_names <- function(name1, year1, name2, year2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2 && year1 == year2)
}
# cartesian product of all combinations
combinations <- mmpf::cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))
# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$Year.x[i], combinations$full_name[i], combinations$Year.y[i])
}
# Filter on the indicator vector
marathonM_times <- combinations[indicator,]
rm("combinations", "marathon", "race_times", "indicator", "match_names", "i", "match_names", "fData", "marathonM")
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.Y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
View(marathonM_times)
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S", origin = "1900-01-01")
View(marathonM_times)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
setwd("~/UGENT -  statistical data analysis/STATISTICAL DATA ANALYSIS/thesis/R analysis")
fData <- read.csv(file.path("Data", "athlete_events.csv"))
head(fData)
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
dir =  "Data\\scraped\\race times"
files = list.files(path = "Data\\scraped\\race times")
data_frames <- vector(mode = "list", length = length(files))
index <-1
for(file in files){
data_frames[[index]] <- read.csv(file.path(dir, file))
year <- gsub("[^0-9]", replacement = "", file)
data_frames[[index]]$Year <- year
index <- index +  1
}
race_times <- do.call("rbind", data_frames)
rm("index", "dir", "file", "files", "data_frames", "year")
# exclude racers without the racetimes
race_times <- filter(race_times, Time != "")
# The name column in the basis dataset contains first and last name as one, thus i have to paste
race_times$full_name <- paste(race_times$FirstName, race_times$LastName)
# Reformat Name column to string such that we can merge
marathonM$Name <- as.character(marathonM$Name)
# Function to check whether there are two matches of words between names
match_names <- function(name1, year1, name2, year2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2 && year1 == year2)
}
# cartesian product of all combinations
combinations <- mmpf::cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))
# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$Year.x[i], combinations$full_name[i], combinations$Year.y[i])
}
# Filter on the indicator vector
marathonM_times <- combinations[indicator,]
rm("combinations", "marathon", "race_times", "indicator", "match_names", "i", "fData", "marathonM")
backup <- marathonM_times
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)
as.POSIXct(marathonM_times$Time,format="%H:%M:%S", origin = "1900-01-01")
marathonM_times <- backup
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
View(marathonM_times)
marathonM_times <- backup
# reordering the columns
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
marathonM_times <- backup
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)
View(marathonM_times)
marathonM_times$Year <- as.numeric(marathonM_times$Year)
# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
convert_to_secs <- function(time){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
str(marathonM_times)
marathonM_times <- backup
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Time", "Position")
# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)
# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
convert_to_secs <- function(time){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
browser()
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
?format
# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
return(as.numeric(format(time, "%h")) * 60 + as.numeric(format(time, "%m")) + as.numeric(format(time, "%s"))/60)
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
View(marathonM_times)
str(marathonM_times)
backup <- marathonM_times
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")
str(marthonM_times)
str(marathonM_times)
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
marathonM_times$Time_secs <- convert_to_secs(marathonM_times$Time)
# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
View(marathonM_times)
marathonM_times$Time <- format(marathonM_times$Time, "%H:%M:%S")
str(marathonM_times)
# all rows that contain na values will be removed
marathonM_times <- na.omit(marathonM_times)
head(marathonM_times)
View(backup)
marathonM_times <- backup
# reordering the columns
marathonM_times$Time <- as.POSIXct(marathonM_times$Time,format="%H:%M:%S")
View(marathonM_times)
View(backup)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse, mmpf)
setwd("~/UGENT -  statistical data analysis/STATISTICAL DATA ANALYSIS/thesis/R analysis")
fData <- read.csv(file.path("Data", "athlete_events.csv"))
head(fData)
marathon <- filter(fData, grepl("Marathon", fData$Event))
marathonM <- filter(marathon, Sex == "M")
marathonF <- filter(marathon, Sex == "F")
paste("The mens dataset contains:", dim(marathonM)[1], "runners.")
paste("The womens dataset contains:", dim(marathonF)[1], "runners.")
dir =  "Data\\scraped\\race times"
files = list.files(path = "Data\\scraped\\race times")
data_frames <- vector(mode = "list", length = length(files))
index <-1
for(file in files){
data_frames[[index]] <- read.csv(file.path(dir, file))
year <- gsub("[^0-9]", replacement = "", file)
data_frames[[index]]$Year <- year
index <- index +  1
}
race_times <- do.call("rbind", data_frames)
rm("index", "dir", "file", "files", "data_frames", "year")
```{r combining the two datasets, echo=FALSE}
# exclude racers without the racetimes
race_times <- filter(race_times, Time != "")
# The name column in the basis dataset contains first and last name as one, thus i have to paste
race_times$full_name <- paste(race_times$FirstName, race_times$LastName)
# Reformat Name column to string such that we can merge
marathonM$Name <- as.character(marathonM$Name)
# Function to check whether there are two matches of words between names
match_names <- function(name1, year1, name2, year2){
vec_name1 <- unlist(strsplit(name1, split = " "))
vec_name2 <- unlist(strsplit(name2, split = " "))
return(length(intersect(vec_name1, vec_name2)) >= 2 && year1 == year2)
}
# cartesian product of all combinations
combinations <- mmpf::cartesianExpand(marathonM, race_times)
indicator <- vector(length = length(combinations$nam))
# Compute the output of the function to each row
for(i in 1:nrow(combinations)){
indicator[i] <- match_names(combinations$Name[i], combinations$Year.x[i], combinations$full_name[i], combinations$Year.y[i])
}
# Filter on the indicator vector
marathonM_times <- combinations[indicator,]
rm("combinations", "marathon", "race_times", "match_names", "i", "fData", "marathonM")
backup <- marathonM_times
# reordering the columns
marathonM_times$Time <- as.POSIXct(marathonM_times$Time, format="%H:%M:%S")
marathonM_times <- marathonM_times[, c("ID","Year.y", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")]
colnames(marathonM_times) <- c("ID","Year", "full_name", "Age", "Height", "Weight", "Nationality", "Position", "Time")
# reformat the columns
marathonM_times$Year <- as.numeric(marathonM_times$Year)
# functions to express the race time in minutes and seconds
convert_to_mins <- function(time){
return(as.numeric(format(time, "%H")) * 60 + as.numeric(format(time, "%M")) + as.numeric(format(time, "%S"))/60)
}
convert_to_secs <- function(time){
return(as.numeric(format(time, "%H")) * 3600 + as.numeric(format(time, "%M")) * 60 + as.numeric(format(time, "%S")))
}
# create columns that contain time in minutes and seconds
marathonM_times$Time_mins <- convert_to_mins(marathonM_times$Time)
marathonM_times$Time_secs <- convert_to_secs(marathonM_times$Time)
marathonM_times$Time <- format(marathonM_times$Time, "%H:%M:%S")
# all rows that contain na values will be removed
marathonM_times <- na.omit(marathonM_times)
rm("convert_to_mins", "convert_to_secs")
head(marathonM_times)
